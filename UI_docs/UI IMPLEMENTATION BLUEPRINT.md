UI IMPLEMENTATION BLUEPRINT

FOR VANNA INTELLIGENT DATA ASSISTANT
(Full-System Interfaces — Best Practices Edition)**
Version 1.0 — Prepared for Enterprise Build

1. PURPOSE OF THIS DOCUMENT

This blueprint defines the end-to-end UI architecture, UX flow, components, states, and integration strategy for building the complete frontend experience of the Vanna-powered Oracle analytics assistant.

It ensures the UI fully exposes:

All Vanna capabilities

All backend features implemented (Tools, Logging, Observability, Governance)

Security constraints

Prompt safety and schema-awareness

Visualization and file generation

Future extensions (RBAC, Admin Console, Multi-Agent)

2. HIGH-LEVEL UI GOALS
Primary Objectives

Provide a clean, stable, UTF-8-safe interface for all users.

Deliver a guided analytics experience built on top of Vanna Agents.

Ensure the UI reflects the full functional feature-set:

LLM Chat

SQL Execution

Data Visualization

Schema Exploration

Past Query Memory

Tool Diagnostics

Logs & Observability Output

Add guardrails ensuring:

No invalid SQL

No unsafe file operations

No schema overexposure

Provide a foundation for enterprise expansion (SSO/RBAC/Admin dashboard).

3. ARCHITECTURAL OVERVIEW
3.1 Frontend Tech Stack (Recommended Best Practice)

Framework: React + TypeScript (or Vue 3 if preferred)

Build System: Vite

State Management: Zustand (lightweight + simple)

Styling: TailwindCSS

Visualization: Apache ECharts or Plotly.js

Notifications: React Hot Toast

Transport: SSE + WebSockets fallback

3.2 API Integration Layer

The UI will communicate with:

Endpoint	Purpose
/api/vanna/v2/chat_sse	Main streaming chat
/api/vanna/v2/chat_poll	Fallback
/api/vanna/v2/chat_websocket	Real-time high-frequency use
/api/health/ready	Connectivity check
/frontend-static/*	Local static assets
4. FEATURE-COMPLETE UI MODULES

Below is the full list of components that must be delivered.

4.1 Authentication Module
Features

Email-based front-end mock auth (cookie token).

SSO-ready design (OIDC/SAML in future).

States

Logged Out → Show Login card.

Logged In → Load chat interface.

Best Practices

Auth token stored in cookie SameSite=Lax.

Must prepend all API calls with x-user-email.

4.2 Main Chat Interface (Core of Vanna UI)
Capabilities

✔ Oracle-backed SQL answering
✔ LLM natural language conversation
✔ Tool-call explanations
✔ Query result tables
✔ Chart generation previews
✔ File exports
✔ Error surfacing (tool failures, SQL errors, malformed JSON)

UI Elements

Chat thread

Input bar

Streaming response area

Tool execution cards

SQL preview panel

Schema awareness pills

Loading indicators

Latency indicator

Request tracing ID display

UX Rules

User sees step-by-step tool actions as Vanna runs tools.

SQL queries are rendered inside collapsible panels.

Returned data tables use virtual scrolling + search + export CSV.

Chart previews displayed in modal + “Save to FileSystem” option.

4.3 Schema Exploration Panel
Purpose

Give the user a reliable source of truth for Oracle schema.

Features

Tables list

Click → Column list

Column details (type, nullability, constraints)

DDL viewer

Integration with “Generate SQL from schema”

Best Practices

Cache schema locally per session

Sync with backend daily or via “Refresh Schema” button

4.4 Query History + Memory Explorer

Matches Vanna’s memory storage.

Features

Show past successful tool uses

Click → Re-run query

Click → Inspect SQL

Click → Inspect tool outputs

Search by question text

Filter by table/tool

4.5 Visualization Studio
Features

Show charts generated by the LLM

If LLM returns raw data → user can pick chart:

Bar

Line

Pie

Scatter

Allow export:

PNG

HTML standalone (uses your LocalFileSystem)

4.6 System Status & Observability Panel

Displays core application health.

Metrics shown:

DB: Oracle connection state

LLM Provider + latency average

Cache: Redis enabled/disabled

ChromaDB: collection state

Server logs (tail 100 lines via SSE)

Request ID + Trace ID for last call

4.7 Admin Console (Phase 2)
Functions

View system logs

Test DB connection

Rebuild semantic embeddings

Backup and purge ChromaDB

Reset circuit breaker

Manage users / RBAC

5. SCREEN FLOW DIAGRAM (Simplified)
Login
  ↓
Landing Page (Chat Panel + Left Sidebar)
  ↓
------------------------------------------------------
| Sidebar: Schema | History | Visualizations | Admin |
------------------------------------------------------
| Chat Panel (Center)                                |
| Tool Actions Panel (Right side collapsible)        |
------------------------------------------------------

6. EXECUTION PLAN
Phase 1 — Foundation (Week 1–2)

Implement static hosting under /frontend-static/

Create basic React app (Vite)

Add login UI

Add API connectivity layer

Add chat scaffold + SSE reader

Add UTF-8 and CSP compliance

Phase 2 — Core Chat + SQL Engine UI (Week 2–3)

Render tool-calls

Render SQL blocks

Render query tables

Add trace ID + duration

Add retry and fix suggestions

Phase 3 — Schema Explorer + Memory UI (Week 3–4)

Sidebar navigation

Load schema from API

Build history explorer

Connect to Vanna memory tools

Phase 4 — Visualization Suite (Week 4–5)

Support ECharts rendering

Export to PNG/HTML

Integrate with LocalFileSystem

Phase 5 — Observability Panel (Week 5)

SSE logs

Circuit breaker state

Cache status

DB status

Phase 6 — Admin Console (Optional, Week 6)

User management

Rebuild embeddings

Database diagnostics

Backup/Purge ChromaDB

7. SECURITY & GOVERNANCE REQUIREMENTS
Mandatory

✔ Enforce prompt-safety UI rules (from prompt_security_ui.md)
✔ Disallow multi-statement SQL
✔ Never expose system paths or internal tables
✔ Sanitize filenames
✔ Display only safe errors to UI

8. DELIVERABLES
Frontend Deliverables

/frontend/ full React application

Components library

Static assets under /frontend-static

Documentation Deliverables

UI README

API integration guide

Component architecture map

9. FINAL RECOMMENDATION

This blueprint gives you:

A complete, enterprise-grade UI architecture

A step-by-step execution plan

A design that exposes all core Vanna features

Full alignment with your backend implementation

A scalable path for future enhancements

You now have everything needed to begin building the modern UI that your system deserves.